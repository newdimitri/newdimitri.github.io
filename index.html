<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="深度学习 机器学习 网络安全 神经网络">
<meta property="og:type" content="website">
<meta property="og:title" content="于祥学习笔记">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="于祥学习笔记">
<meta property="og:description" content="深度学习 机器学习 网络安全 神经网络">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="于祥学习笔记">
<meta name="twitter:description" content="深度学习 机器学习 网络安全 神经网络">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>于祥学习笔记</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">于祥学习笔记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录于祥学过的内容</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/14/recommender_system/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yimitri">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于祥学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/14/recommender_system/" itemprop="url">个性化推荐</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-14T22:15:08+08:00">
                2018-12-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>在网络技术不断发展和电子商务规模不断扩大的背景下，商品数量和种类快速增长，用户需要花费大量时间才能找到自己想买的商品，这就是信息超载问题。为了解决这个难题，推荐系统（Recommender System）应运而生。</p>
<p>个性化推荐系统是信息过滤系统（Information Filtering System）的子集，它可以用在很多领域，如电影、音乐、电商和 Feed 流推荐等。推荐系统通过分析、挖掘用户行为，发现用户的个性化需求与兴趣特点，将用户可能感兴趣的信息或商品推荐给用户。与搜索引擎不同，推荐系统不需要用户准确地描述出自己的需求，而是根据分析历史行为建模，主动提供满足用户兴趣和需求的信息。</p>
<p>传统的推荐系统方法主要有：</p>
<ul>
<li>协同过滤推荐（Collaborative Filtering Recommendation）：该方法收集分析用户历史行为、活动、偏好，计算一个用户与其他用户的相似度，利用目标用户的相似用户对商品评价的加权评价值，来预测目标用户对特定商品的喜好程度。优点是可以给用户推荐未浏览过的新产品；缺点是对于没有任何行为的新用户存在冷启动的问题，同时也存在用户与商品之间的交互数据不够多造成的稀疏问题，会导致模型难以找到相近用户。</li>
<li>基于内容过滤推荐[<a href="#参考文献">1</a>]（Content-based Filtering Recommendation）：该方法利用商品的内容描述，抽象出有意义的特征，通过计算用户的兴趣和商品描述之间的相似度，来给用户做推荐。优点是简单直接，不需要依据其他用户对商品的评价，而是通过商品属性进行商品相似度度量，从而推荐给用户所感兴趣商品的相似商品；缺点是对于没有任何行为的新用户同样存在冷启动的问题。</li>
<li>组合推荐[<a href="#参考文献">2</a>]（Hybrid Recommendation）：运用不同的输入和技术共同进行推荐，以弥补各自推荐技术的缺点。</li>
</ul>
<p>其中协同过滤是应用最广泛的技术之一，它又可以分为多个子类：基于用户 （User-Based）的推荐[<a href="#参考文献">3</a>] 、基于物品（Item-Based）的推荐[<a href="#参考文献">4</a>]、基于社交网络关系（Social-Based）的推荐[<a href="#参考文献">5</a>]、基于模型（Model-based）的推荐等。1994年明尼苏达大学推出的GroupLens系统[<a href="#参考文献">3</a>]一般被认为是推荐系统成为一个相对独立的研究方向的标志。该系统首次提出了基于协同过滤来完成推荐任务的思想，此后，基于该模型的协同过滤推荐引领了推荐系统十几年的发展方向。</p>
<p>深度学习具有优秀的自动提取特征的能力，能够学习多层次的抽象特征表示，并对异质或跨域的内容信息进行学习，可以一定程度上处理推荐系统冷启动问题[<a href="#参考文献">6</a>]。本教程主要介绍个性化推荐的深度学习模型，以及如何使用PaddlePaddle实现模型。</p>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>我们使用包含用户信息、电影信息与电影评分的数据集作为个性化推荐的应用场景。当我们训练好模型后，只需要输入对应的用户ID和电影ID，就可以得出一个匹配的分数（范围[0,5]，分数越高视为兴趣越大），然后根据所有电影的推荐得分排序，推荐给用户可能感兴趣的电影。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input movie_id: 1962</span><br><span class="line">Input user_id: 1</span><br><span class="line">Prediction Score is 4.25</span><br></pre></td></tr></table></figure>
<h2 id="模型概览"><a href="#模型概览" class="headerlink" title="模型概览"></a>模型概览</h2><p>本章中，我们首先介绍YouTube的视频推荐系统[<a href="#参考文献">7</a>]，然后介绍我们实现的融合推荐模型。</p>
<h3 id="YouTube的深度神经网络推荐系统"><a href="#YouTube的深度神经网络推荐系统" class="headerlink" title="YouTube的深度神经网络推荐系统"></a>YouTube的深度神经网络推荐系统</h3><p>YouTube是世界上最大的视频上传、分享和发现网站，YouTube推荐系统为超过10亿用户从不断增长的视频库中推荐个性化的内容。整个系统由两个神经网络组成：候选生成网络和排序网络。候选生成网络从百万量级的视频库中生成上百个候选，排序网络对候选进行打分排序，输出排名最高的数十个结果。系统结构如图1所示：</p>
<p align="center"><br><img src="https://github.com/PaddlePaddle/book/blob/develop/05.recommender_system/image/YouTube_Overview.png?raw=true" width="70%"><br><br>图1. YouTube 推荐系统结构<br></p>

<h4 id="候选生成网络（Candidate-Generation-Network）"><a href="#候选生成网络（Candidate-Generation-Network）" class="headerlink" title="候选生成网络（Candidate Generation Network）"></a>候选生成网络（Candidate Generation Network）</h4><p>候选生成网络将推荐问题建模为一个类别数极大的多类分类问题：对于一个Youtube用户，使用其观看历史（视频ID）、搜索词记录（search tokens）、人口学信息（如地理位置、用户登录设备）、二值特征（如性别，是否登录）和连续特征（如用户年龄）等，对视频库中所有视频进行多分类，得到每一类别的分类结果（即每一个视频的推荐概率），最终输出概率较高的几百个视频。</p>
<p>首先，将观看历史及搜索词记录这类历史信息，映射为向量后取平均值得到定长表示；同时，输入人口学特征以优化新用户的推荐效果，并将二值特征和连续特征归一化处理到[0, 1]范围。接下来，将所有特征表示拼接为一个向量，并输入给非线形多层感知器（MLP，详见<a href="https://github.com/PaddlePaddle/book/blob/develop/02.recognize_digits/README.cn.md" target="_blank" rel="noopener">识别数字</a>教程）处理。最后，训练时将MLP的输出给softmax做分类，预测时计算用户的综合特征（MLP的输出）与所有视频的相似度，取得分最高的$k$个作为候选生成网络的筛选结果。图2显示了候选生成网络结构。</p>
<p align="center"><br><img src="https://github.com/PaddlePaddle/book/blob/develop/05.recommender_system/image/Deep_candidate_generation_model_architecture.png?raw=true" width="70%"><br><br>图2. 候选生成网络结构<br></p>

<p>对于一个用户$U$，预测此刻用户要观看的视频$\omega$为视频$i$的概率公式为：</p>
<p>$$P(\omega=i|u)=\frac{e^{v_{i}u}}{\sum_{j \in V}e^{v_{j}u}}$$</p>
<p>其中$u$为用户$U$的特征表示，$V$为视频库集合，$v_i$为视频库中第$i$个视频的特征表示。$u$和$v_i$为长度相等的向量，两者点积可以通过全连接层实现。</p>
<p>考虑到softmax分类的类别数非常多，为了保证一定的计算效率：1）训练阶段，使用负样本类别采样将实际计算的类别数缩小至数千；2）推荐（预测）阶段，忽略softmax的归一化计算（不影响结果），将类别打分问题简化为点积（dot product）空间中的最近邻（nearest neighbor）搜索问题，取与$u$最近的$k$个视频作为生成的候选。</p>
<h4 id="排序网络（Ranking-Network）"><a href="#排序网络（Ranking-Network）" class="headerlink" title="排序网络（Ranking Network）"></a>排序网络（Ranking Network）</h4><p>排序网络的结构类似于候选生成网络，但是它的目标是对候选进行更细致的打分排序。和传统广告排序中的特征抽取方法类似，这里也构造了大量的用于视频排序的相关特征（如视频 ID、上次观看时间等）。这些特征的处理方式和候选生成网络类似，不同之处是排序网络的顶部是一个加权逻辑回归（weighted logistic regression），它对所有候选视频进行打分，从高到底排序后将分数较高的一些视频返回给用户。</p>
<h3 id="融合推荐模型"><a href="#融合推荐模型" class="headerlink" title="融合推荐模型"></a>融合推荐模型</h3><p>本节会使卷积神经网络（Convolutional Neural Networks）来学习电影名称的表示。下面会依次介绍文本卷积神经网络以及融合推荐模型。</p>
<h4 id="文本卷积神经网络（CNN）"><a href="#文本卷积神经网络（CNN）" class="headerlink" title="文本卷积神经网络（CNN）"></a>文本卷积神经网络（CNN）</h4><p>卷积神经网络经常用来处理具有类似网格拓扑结构（grid-like topology）的数据。例如，图像可以视为二维网格的像素点，自然语言可以视为一维的词序列。卷积神经网络可以提取多种局部特征，并对其进行组合抽象得到更高级的特征表示。实验表明，卷积神经网络能高效地对图像及文本问题进行建模处理。</p>
<p>卷积神经网络主要由卷积（convolution）和池化（pooling）操作构成，其应用及组合方式灵活多变，种类繁多。本小结我们以如图3所示的网络进行讲解：</p>
<p align="center"><br><img src="https://github.com/PaddlePaddle/book/blob/develop/05.recommender_system/image/text_cnn.png?raw=true" width="80%" align="center"><br><br>图3. 卷积神经网络文本分类模型<br></p>

<p>假设待处理句子的长度为$n$，其中第$i$个词的词向量（word embedding）为$x_i\in\mathbb{R}^k$，$k$为维度大小。</p>
<p>首先，进行词向量的拼接操作：将每$h$个词拼接起来形成一个大小为$h$的词窗口，记为$x_{i:i+h-1}$，它表示词序列$x_{i},x_{i+1},\ldots,x_{i+h-1}$的拼接，其中，$i$表示词窗口中第一个词在整个句子中的位置，取值范围从$1$到$n-h+1$，$x_{i:i+h-1}\in\mathbb{R}^{hk}$。</p>
<p>其次，进行卷积操作：把卷积核(kernel)$w\in\mathbb{R}^{hk}$应用于包含$h$个词的窗口$x_{i:i+h-1}$，得到特征$c_i=f(w\cdot x_{i:i+h-1}+b)$，其中$b\in\mathbb{R}$为偏置项（bias），$f$为非线性激活函数，如$sigmoid$。将卷积核应用于句子中所有的词窗口${x_{1:h},x_{2:h+1},\ldots,x_{n-h+1:n}}$，产生一个特征图（feature map）：</p>
<p>$$c=[c_1,c_2,\ldots,c_{n-h+1}], c \in \mathbb{R}^{n-h+1}$$</p>
<p>接下来，对特征图采用时间维度上的最大池化（max pooling over time）操作得到此卷积核对应的整句话的特征$\hat c$，它是特征图中所有元素的最大值：</p>
<p>$$\hat c=max(c)$$</p>
<h4 id="模型概览-1"><a href="#模型概览-1" class="headerlink" title="模型概览"></a>模型概览</h4><p>在融合推荐模型的电影推荐系统中：</p>
<ol>
<li><p>首先，使用用户特征和电影特征作为神经网络的输入，其中：</p>
<ul>
<li><p>用户特征融合了四个属性信息，分别是用户ID、性别、职业和年龄。</p>
</li>
<li><p>电影特征融合了三个属性信息，分别是电影ID、电影类型ID和电影名称。</p>
</li>
</ul>
</li>
<li><p>对用户特征，将用户ID映射为维度大小为256的向量表示，输入全连接层，并对其他三个属性也做类似的处理。然后将四个属性的特征表示分别全连接并相加。</p>
</li>
<li><p>对电影特征，将电影ID以类似用户ID的方式进行处理，电影类型ID以向量的形式直接输入全连接层，电影名称用文本卷积神经网络得到其定长向量表示。然后将三个属性的特征表示分别全连接并相加。</p>
</li>
<li><p>得到用户和电影的向量表示后，计算二者的余弦相似度作为推荐系统的打分。最后，用该相似度打分和用户真实打分的差异的平方作为该回归模型的损失函数。</p>
</li>
</ol>
<p align="center"><br><br><img src="https://github.com/PaddlePaddle/book/blob/develop/05.recommender_system/image/rec_regression_network.png?raw=true" width="90%"><br><br>图4. 融合推荐模型<br></p>

<h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><h3 id="数据介绍与下载"><a href="#数据介绍与下载" class="headerlink" title="数据介绍与下载"></a>数据介绍与下载</h3><p>我们以 <a href="http://files.grouplens.org/datasets/movielens/ml-1m.zip" target="_blank" rel="noopener">MovieLens 百万数据集（ml-1m）</a>为例进行介绍。ml-1m 数据集包含了 6,000 位用户对 4,000 部电影的 1,000,000 条评价（评分范围 1~5 分，均为整数），由 GroupLens Research 实验室搜集整理。</p>
<p>Paddle在API中提供了自动加载数据的模块。数据模块为 <code>paddle.dataset.movielens</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line">movie_info = paddle.dataset.movielens.movie_info()</span><br><span class="line"><span class="keyword">print</span> movie_info.values()[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Run this block to show dataset's documentation</span></span><br><span class="line"><span class="comment"># help(paddle.dataset.movielens)</span></span><br></pre></td></tr></table></figure>
<p>在原始数据中包含电影的特征数据，用户的特征数据，和用户对电影的评分。</p>
<p>例如，其中某一个电影特征为:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movie_info = paddle.dataset.movielens.movie_info()</span><br><span class="line"><span class="keyword">print</span> movie_info.values()[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<pre><code>&lt;MovieInfo id(1), title(Toy Story ), categories([&apos;Animation&apos;, &quot;Children&apos;s&quot;, &apos;Comedy&apos;])&gt;
</code></pre><p>这表示，电影的id是1，标题是《Toy Story》，该电影被分为到三个类别中。这三个类别是动画，儿童，喜剧。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user_info = paddle.dataset.movielens.user_info()</span><br><span class="line"><span class="keyword">print</span> user_info.values()[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<pre><code>&lt;UserInfo id(1), gender(F), age(1), job(10)&gt;
</code></pre><p>这表示，该用户ID是1，女性，年龄比18岁还年轻。职业ID是10。</p>
<p>其中，年龄使用下列分布</p>
<ul>
<li>1:  “Under 18”</li>
<li>18:  “18-24”</li>
<li>25:  “25-34”</li>
<li>35:  “35-44”</li>
<li>45:  “45-49”</li>
<li>50:  “50-55”</li>
<li>56:  “56+”</li>
</ul>
<p>职业是从下面几种选项里面选则得出:</p>
<ul>
<li>0:  “other” or not specified</li>
<li>1:  “academic/educator”</li>
<li>2:  “artist”</li>
<li>3:  “clerical/admin”</li>
<li>4:  “college/grad student”</li>
<li>5:  “customer service”</li>
<li>6:  “doctor/health care”</li>
<li>7:  “executive/managerial”</li>
<li>8:  “farmer”</li>
<li>9:  “homemaker”</li>
<li>10:  “K-12 student”</li>
<li>11:  “lawyer”</li>
<li>12:  “programmer”</li>
<li>13:  “retired”</li>
<li>14:  “sales/marketing”</li>
<li>15:  “scientist”</li>
<li>16:  “self-employed”</li>
<li>17:  “technician/engineer”</li>
<li>18:  “tradesman/craftsman”</li>
<li>19:  “unemployed”</li>
<li>20:  “writer”</li>
</ul>
<p>而对于每一条训练/测试数据，均为 &lt;用户特征&gt; + &lt;电影特征&gt; + 评分。</p>
<p>例如，我们获得第一条训练数据:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">train_set_creator = paddle.dataset.movielens.train()</span><br><span class="line">train_sample = next(train_set_creator())</span><br><span class="line">uid = train_sample[<span class="number">0</span>]</span><br><span class="line">mov_id = train_sample[len(user_info[uid].value())]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"User %s rates Movie %s with Score %s"</span>%(user_info[uid], movie_info[mov_id], train_sample[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<pre><code>User &lt;UserInfo id(1), gender(F), age(1), job(10)&gt; rates Movie &lt;MovieInfo id(1193), title(One Flew Over the Cuckoo&apos;s Nest ), categories([&apos;Drama&apos;])&gt; with Score [5.0]
</code></pre><p>即用户1对电影1193的评价为5分。</p>
<h2 id="模型配置说明"><a href="#模型配置说明" class="headerlink" title="模型配置说明"></a>模型配置说明</h2><p>下面我们开始根据输入数据的形式配置模型。首先引入所需的库函数以及定义全局变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line"><span class="keyword">import</span> paddle.fluid <span class="keyword">as</span> fluid</span><br><span class="line"><span class="keyword">import</span> paddle.fluid.layers <span class="keyword">as</span> layers</span><br><span class="line"><span class="keyword">import</span> paddle.fluid.nets <span class="keyword">as</span> nets</span><br><span class="line"></span><br><span class="line">IS_SPARSE = <span class="keyword">True</span></span><br><span class="line">USE_GPU = <span class="keyword">False</span></span><br><span class="line">BATCH_SIZE = <span class="number">256</span></span><br></pre></td></tr></table></figure>
<p>然后为我们的用户特征综合模型定义模型配置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_usr_combined_features</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    USR_DICT_SIZE = paddle.dataset.movielens.max_user_id() + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    uid = layers.data(name=<span class="string">'user_id'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">'int64'</span>)</span><br><span class="line"></span><br><span class="line">    usr_emb = layers.embedding(</span><br><span class="line">        input=uid,</span><br><span class="line">        dtype=<span class="string">'float32'</span>,</span><br><span class="line">        size=[USR_DICT_SIZE, <span class="number">32</span>],</span><br><span class="line">        param_attr=<span class="string">'user_table'</span>,</span><br><span class="line">        is_sparse=IS_SPARSE)</span><br><span class="line"></span><br><span class="line">    usr_fc = layers.fc(input=usr_emb, size=<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    USR_GENDER_DICT_SIZE = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    usr_gender_id = layers.data(name=<span class="string">'gender_id'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">'int64'</span>)</span><br><span class="line"></span><br><span class="line">    usr_gender_emb = layers.embedding(</span><br><span class="line">        input=usr_gender_id,</span><br><span class="line">        size=[USR_GENDER_DICT_SIZE, <span class="number">16</span>],</span><br><span class="line">        param_attr=<span class="string">'gender_table'</span>,</span><br><span class="line">        is_sparse=IS_SPARSE)</span><br><span class="line"></span><br><span class="line">    usr_gender_fc = layers.fc(input=usr_gender_emb, size=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    USR_AGE_DICT_SIZE = len(paddle.dataset.movielens.age_table)</span><br><span class="line">    usr_age_id = layers.data(name=<span class="string">'age_id'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">"int64"</span>)</span><br><span class="line"></span><br><span class="line">    usr_age_emb = layers.embedding(</span><br><span class="line">        input=usr_age_id,</span><br><span class="line">        size=[USR_AGE_DICT_SIZE, <span class="number">16</span>],</span><br><span class="line">        is_sparse=IS_SPARSE,</span><br><span class="line">        param_attr=<span class="string">'age_table'</span>)</span><br><span class="line"></span><br><span class="line">    usr_age_fc = layers.fc(input=usr_age_emb, size=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    USR_JOB_DICT_SIZE = paddle.dataset.movielens.max_job_id() + <span class="number">1</span></span><br><span class="line">    usr_job_id = layers.data(name=<span class="string">'job_id'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">"int64"</span>)</span><br><span class="line"></span><br><span class="line">    usr_job_emb = layers.embedding(</span><br><span class="line">        input=usr_job_id,</span><br><span class="line">        size=[USR_JOB_DICT_SIZE, <span class="number">16</span>],</span><br><span class="line">        param_attr=<span class="string">'job_table'</span>,</span><br><span class="line">        is_sparse=IS_SPARSE)</span><br><span class="line"></span><br><span class="line">    usr_job_fc = layers.fc(input=usr_job_emb, size=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    concat_embed = layers.concat(</span><br><span class="line">        input=[usr_fc, usr_gender_fc, usr_age_fc, usr_job_fc], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    usr_combined_features = layers.fc(input=concat_embed, size=<span class="number">200</span>, act=<span class="string">"tanh"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> usr_combined_features</span><br></pre></td></tr></table></figure>
<p>如上述代码所示，对于每个用户，我们输入4维特征。其中包括user_id,gender_id,age_id,job_id。这几维特征均是简单的整数值。为了后续神经网络处理这些特征方便，我们借鉴NLP中的语言模型，将这几维离散的整数值，变换成embedding取出。分别形成usr_emb, usr_gender_emb, usr_age_emb, usr_job_emb。</p>
<p>然后，我们对于所有的用户特征，均输入到一个全连接层(fc)中。将所有特征融合为一个200维度的特征。</p>
<p>进而，我们对每一个电影特征做类似的变换，网络配置为:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_mov_combined_features</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    MOV_DICT_SIZE = paddle.dataset.movielens.max_movie_id() + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    mov_id = layers.data(name=<span class="string">'movie_id'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">'int64'</span>)</span><br><span class="line"></span><br><span class="line">    mov_emb = layers.embedding(</span><br><span class="line">        input=mov_id,</span><br><span class="line">        dtype=<span class="string">'float32'</span>,</span><br><span class="line">        size=[MOV_DICT_SIZE, <span class="number">32</span>],</span><br><span class="line">        param_attr=<span class="string">'movie_table'</span>,</span><br><span class="line">        is_sparse=IS_SPARSE)</span><br><span class="line"></span><br><span class="line">    mov_fc = layers.fc(input=mov_emb, size=<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">    CATEGORY_DICT_SIZE = len(paddle.dataset.movielens.movie_categories())</span><br><span class="line"></span><br><span class="line">    category_id = layers.data(</span><br><span class="line">        name=<span class="string">'category_id'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">'int64'</span>, lod_level=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    mov_categories_emb = layers.embedding(</span><br><span class="line">        input=category_id, size=[CATEGORY_DICT_SIZE, <span class="number">32</span>], is_sparse=IS_SPARSE)</span><br><span class="line"></span><br><span class="line">    mov_categories_hidden = layers.sequence_pool(</span><br><span class="line">        input=mov_categories_emb, pool_type=<span class="string">"sum"</span>)</span><br><span class="line"></span><br><span class="line">    MOV_TITLE_DICT_SIZE = len(paddle.dataset.movielens.get_movie_title_dict())</span><br><span class="line"></span><br><span class="line">    mov_title_id = layers.data(</span><br><span class="line">        name=<span class="string">'movie_title'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">'int64'</span>, lod_level=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    mov_title_emb = layers.embedding(</span><br><span class="line">        input=mov_title_id, size=[MOV_TITLE_DICT_SIZE, <span class="number">32</span>], is_sparse=IS_SPARSE)</span><br><span class="line"></span><br><span class="line">    mov_title_conv = nets.sequence_conv_pool(</span><br><span class="line">        input=mov_title_emb,</span><br><span class="line">        num_filters=<span class="number">32</span>,</span><br><span class="line">        filter_size=<span class="number">3</span>,</span><br><span class="line">        act=<span class="string">"tanh"</span>,</span><br><span class="line">        pool_type=<span class="string">"sum"</span>)</span><br><span class="line"></span><br><span class="line">    concat_embed = layers.concat(</span><br><span class="line">        input=[mov_fc, mov_categories_hidden, mov_title_conv], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    mov_combined_features = layers.fc(input=concat_embed, size=<span class="number">200</span>, act=<span class="string">"tanh"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mov_combined_features</span><br></pre></td></tr></table></figure>
<p>电影标题名称(title)是一个序列的整数，整数代表的是这个词在索引序列中的下标。这个序列会被送入 <code>sequence_conv_pool</code> 层，这个层会在时间维度上使用卷积和池化。因为如此，所以输出会是固定长度，尽管输入的序列长度各不相同。</p>
<p>最后，我们定义一个<code>inference_program</code>来使用余弦相似度计算用户特征与电影特征的相似性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inference_program</span><span class="params">()</span>:</span></span><br><span class="line">    usr_combined_features = get_usr_combined_features()</span><br><span class="line">    mov_combined_features = get_mov_combined_features()</span><br><span class="line"></span><br><span class="line">    inference = layers.cos_sim(X=usr_combined_features, Y=mov_combined_features)</span><br><span class="line">    scale_infer = layers.scale(x=inference, scale=<span class="number">5.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> scale_infer</span><br></pre></td></tr></table></figure>
<p>进而，我们定义一个<code>train_program</code>来使用<code>inference_program</code>计算出的结果，在标记数据的帮助下来计算误差。我们还定义了一个<code>optimizer_func</code>来定义优化器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_program</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    scale_infer = inference_program()</span><br><span class="line"></span><br><span class="line">    label = layers.data(name=<span class="string">'score'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">'float32'</span>)</span><br><span class="line">    square_cost = layers.square_error_cost(input=scale_infer, label=label)</span><br><span class="line">    avg_cost = layers.mean(square_cost)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [avg_cost, scale_infer]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimizer_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> fluid.optimizer.SGD(learning_rate=<span class="number">0.2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><h3 id="定义训练环境"><a href="#定义训练环境" class="headerlink" title="定义训练环境"></a>定义训练环境</h3><p>定义您的训练环境，可以指定训练是发生在CPU还是GPU上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use_cuda = <span class="keyword">False</span></span><br><span class="line">place = fluid.CUDAPlace(<span class="number">0</span>) <span class="keyword">if</span> use_cuda <span class="keyword">else</span> fluid.CPUPlace()</span><br></pre></td></tr></table></figure>
<h3 id="定义数据提供器"><a href="#定义数据提供器" class="headerlink" title="定义数据提供器"></a>定义数据提供器</h3><p>下一步是为训练和测试定义数据提供器。提供器读入一个大小为 <code>BATCH_SIZE</code>的数据。<code>paddle.dataset.movielens.train</code> 每次会在乱序化后提供一个大小为<code>BATCH_SIZE</code>的数据，乱序化的大小为缓存大小<code>buf_size</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">train_reader = paddle.batch(</span><br><span class="line">    paddle.reader.shuffle(</span><br><span class="line">        paddle.dataset.movielens.train(), buf_size=<span class="number">8192</span>),</span><br><span class="line">    batch_size=BATCH_SIZE)</span><br><span class="line"></span><br><span class="line">test_reader = paddle.batch(</span><br><span class="line">    paddle.dataset.movielens.test(), batch_size=BATCH_SIZE)</span><br></pre></td></tr></table></figure>
<h3 id="构造训练过程-trainer"><a href="#构造训练过程-trainer" class="headerlink" title="构造训练过程(trainer)"></a>构造训练过程(trainer)</h3><p>我们这里构造了一个训练过程，包括训练优化函数。</p>
<h3 id="提供数据"><a href="#提供数据" class="headerlink" title="提供数据"></a>提供数据</h3><p><code>feed_order</code>用来定义每条产生的数据和<code>paddle.layer.data</code>之间的映射关系。比如，<code>movielens.train</code>产生的第一列的数据对应的是<code>user_id</code>这个特征。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">feed_order = [</span><br><span class="line">    <span class="string">'user_id'</span>, <span class="string">'gender_id'</span>, <span class="string">'age_id'</span>, <span class="string">'job_id'</span>, <span class="string">'movie_id'</span>, <span class="string">'category_id'</span>,</span><br><span class="line">    <span class="string">'movie_title'</span>, <span class="string">'score'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="构建训练程序以及测试程序"><a href="#构建训练程序以及测试程序" class="headerlink" title="构建训练程序以及测试程序"></a>构建训练程序以及测试程序</h3><p>分别构建训练程序和测试程序，并引入训练优化器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">main_program = fluid.default_main_program()</span><br><span class="line">star_program = fluid.default_startup_program()</span><br><span class="line">[avg_cost, scale_infer] = train_program()</span><br><span class="line"></span><br><span class="line">test_program = main_program.clone(for_test=<span class="keyword">True</span>)</span><br><span class="line">sgd_optimizer = optimizer_func()</span><br><span class="line">sgd_optimizer.minimize(avg_cost)</span><br><span class="line">exe = fluid.Executor(place)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_test</span><span class="params">(program, reader)</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    feed_var_list = [</span><br><span class="line">        program.global_block().var(var_name) <span class="keyword">for</span> var_name <span class="keyword">in</span> feed_order</span><br><span class="line">    ]</span><br><span class="line">    feeder_test = fluid.DataFeeder(</span><br><span class="line">    feed_list=feed_var_list, place=place)</span><br><span class="line">    test_exe = fluid.Executor(place)</span><br><span class="line">    accumulated = len([avg_cost, scale_infer]) * [<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> test_data <span class="keyword">in</span> reader():</span><br><span class="line">        avg_cost_np = test_exe.run(program=program,</span><br><span class="line">                                               feed=feeder_test.feed(test_data),</span><br><span class="line">                                               fetch_list=[avg_cost, scale_infer])</span><br><span class="line">        accumulated = [x[<span class="number">0</span>] + x[<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">for</span> x <span class="keyword">in</span> zip(accumulated, avg_cost_np)]</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> [x / count <span class="keyword">for</span> x <span class="keyword">in</span> accumulated]</span><br></pre></td></tr></table></figure>
<h3 id="构建训练主循环并开始训练"><a href="#构建训练主循环并开始训练" class="headerlink" title="构建训练主循环并开始训练"></a>构建训练主循环并开始训练</h3><p>我们根据上面定义的训练循环数（<code>PASS_NUM</code>）和一些别的参数，来进行训练循环，并且每次循环都进行一次测试，当测试结果足够好时退出训练并保存训练好的参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Specify the directory path to save the parameters</span></span><br><span class="line">params_dirname = <span class="string">"recommender_system.inference.model"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> paddle.utils.plot <span class="keyword">import</span> Ploter</span><br><span class="line">test_prompt = <span class="string">"Test cost"</span></span><br><span class="line">plot_cost = Ploter(test_prompt)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_loop</span><span class="params">()</span>:</span></span><br><span class="line">    feed_list = [</span><br><span class="line">        main_program.global_block().var(var_name) <span class="keyword">for</span> var_name <span class="keyword">in</span> feed_order</span><br><span class="line">    ]</span><br><span class="line">    feeder = fluid.DataFeeder(feed_list, place)</span><br><span class="line">    exe.run(star_program)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> pass_id <span class="keyword">in</span> range(PASS_NUM):</span><br><span class="line">        <span class="keyword">for</span> batch_id, data <span class="keyword">in</span> enumerate(train_reader()):</span><br><span class="line">            <span class="comment"># train a mini-batch</span></span><br><span class="line">            outs = exe.run(program=main_program,</span><br><span class="line">                               feed=feeder.feed(data),</span><br><span class="line">                               fetch_list=[avg_cost])</span><br><span class="line">            out = np.array(outs[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">            avg_cost_set = train_test(test_program, test_reader)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># get test avg_cost</span></span><br><span class="line">            test_avg_cost = np.array(avg_cost_set).mean()</span><br><span class="line">            plot_cost.append(test_prompt, batch_id, outs[<span class="number">0</span>])</span><br><span class="line">            plot_cost.plot()</span><br><span class="line">            print(<span class="string">"avg_cost: %s"</span> % test_avg_cost)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> batch_id == <span class="number">20</span>:</span><br><span class="line">                <span class="keyword">if</span> params_dirname <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                    fluid.io.save_inference_model(params_dirname, [</span><br><span class="line">                                <span class="string">"user_id"</span>, <span class="string">"gender_id"</span>, <span class="string">"age_id"</span>, <span class="string">"job_id"</span>,</span><br><span class="line">                                <span class="string">"movie_id"</span>, <span class="string">"category_id"</span>, <span class="string">"movie_title"</span></span><br><span class="line">                        ], [scale_infer], exe)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">'BatchID &#123;0&#125;, Test Loss &#123;1:0.2&#125;'</span>.format(pass_id + <span class="number">1</span>,</span><br><span class="line">                                                                  float(test_avg_cost)))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> math.isnan(float(out[<span class="number">0</span>])):</span><br><span class="line">                sys.exit(<span class="string">"got NaN loss, training failed."</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_loop()</span><br></pre></td></tr></table></figure>
<h2 id="应用模型"><a href="#应用模型" class="headerlink" title="应用模型"></a>应用模型</h2><h3 id="生成测试数据"><a href="#生成测试数据" class="headerlink" title="生成测试数据"></a>生成测试数据</h3><p>使用 create_lod_tensor(data, lod, place) 的API来生成细节层次的张量。<code>data</code>是一个序列，每个元素是一个索引号的序列。<code>lod</code>是细节层次的信息，对应于<code>data</code>。比如，data = [[10, 2, 3], [2, 3]] 意味着它包含两个序列，长度分别是3和2。于是相应地 lod = [[3, 2]]，它表明其包含一层细节信息，意味着 <code>data</code> 有两个序列，长度分别是3和2。</p>
<p>在这个预测例子中，我们试着预测用户ID为1的用户对于电影’Hunchback of Notre Dame’的评分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">infer_movie_id = <span class="number">783</span></span><br><span class="line">infer_movie_name = paddle.dataset.movielens.movie_info()[infer_movie_id].title</span><br><span class="line">user_id = fluid.create_lod_tensor([[<span class="number">1</span>]], [[<span class="number">1</span>]], place)</span><br><span class="line">gender_id = fluid.create_lod_tensor([[<span class="number">1</span>]], [[<span class="number">1</span>]], place)</span><br><span class="line">age_id = fluid.create_lod_tensor([[<span class="number">0</span>]], [[<span class="number">1</span>]], place)</span><br><span class="line">job_id = fluid.create_lod_tensor([[<span class="number">10</span>]], [[<span class="number">1</span>]], place)</span><br><span class="line">movie_id = fluid.create_lod_tensor([[<span class="number">783</span>]], [[<span class="number">1</span>]], place) <span class="comment"># Hunchback of Notre Dame</span></span><br><span class="line">category_id = fluid.create_lod_tensor([[<span class="number">10</span>, <span class="number">8</span>, <span class="number">9</span>]], [[<span class="number">3</span>]], place) <span class="comment"># Animation, Children's, Musical</span></span><br><span class="line">movie_title = fluid.create_lod_tensor([[<span class="number">1069</span>, <span class="number">4140</span>, <span class="number">2923</span>, <span class="number">710</span>, <span class="number">988</span>]], [[<span class="number">5</span>]],</span><br><span class="line">                                      place) <span class="comment"># 'hunchback','of','notre','dame','the'</span></span><br></pre></td></tr></table></figure>
<h3 id="构建预测过程并测试"><a href="#构建预测过程并测试" class="headerlink" title="构建预测过程并测试"></a>构建预测过程并测试</h3><p>与训练过程类似，我们需要构建一个预测过程。其中， <code>params_dirname</code>是之前用来存放训练过程中的各个参数的地址。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">place = fluid.CUDAPlace(<span class="number">0</span>) <span class="keyword">if</span> use_cuda <span class="keyword">else</span> fluid.CPUPlace()</span><br><span class="line">exe = fluid.Executor(place)</span><br><span class="line"></span><br><span class="line">inference_scope = fluid.core.Scope()</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>现在我们可以进行预测了。我们要提供的<code>feed_order</code>应该和训练过程一致。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> fluid.scope_guard(inference_scope):</span><br><span class="line">    [inferencer, feed_target_names,</span><br><span class="line">    fetch_targets] = fluid.io.load_inference_model(params_dirname, exe)</span><br><span class="line"></span><br><span class="line">    results = exe.run(inferencer,</span><br><span class="line">                          feed=&#123;</span><br><span class="line">                               <span class="string">'user_id'</span>: user_id,</span><br><span class="line">                              <span class="string">'gender_id'</span>: gender_id,</span><br><span class="line">                              <span class="string">'age_id'</span>: age_id,</span><br><span class="line">                              <span class="string">'job_id'</span>: job_id,</span><br><span class="line">                              <span class="string">'movie_id'</span>: movie_id,</span><br><span class="line">                              <span class="string">'category_id'</span>: category_id,</span><br><span class="line">                              <span class="string">'movie_title'</span>: movie_title</span><br><span class="line">                          &#125;,</span><br><span class="line">                          fetch_list=fetch_targets,</span><br><span class="line">                          return_numpy=<span class="keyword">False</span>)</span><br><span class="line">    predict_rating = np.array(results[<span class="number">0</span>])</span><br><span class="line">    print(<span class="string">"Predict Rating of user id 1 on movie \""</span> + infer_movie_name +</span><br><span class="line">              <span class="string">"\" is "</span> + str(predict_rating[<span class="number">0</span>][<span class="number">0</span>]))</span><br><span class="line">    print(<span class="string">"Actual Rating of user id 1 on movie \""</span> + infer_movie_name +</span><br><span class="line">              <span class="string">"\" is 4."</span>)</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章介绍了传统的推荐系统方法和YouTube的深度神经网络推荐系统，并以电影推荐为例，使用PaddlePaddle训练了一个个性化推荐神经网络模型。推荐系统几乎涵盖了电商系统、社交网络、广告推荐、搜索引擎等领域的方方面面，而在图像处理、自然语言处理等领域已经发挥重要作用的深度学习技术，也将会在推荐系统领域大放异彩。</p>
<p><a name="参考文献"></a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://en.wikipedia.org/wiki/Peter_Brusilovsky" target="_blank" rel="noopener">Peter Brusilovsky</a> (2007). <em>The Adaptive Web</em>. p. 325.</li>
<li>Robin Burke , <a href="http://www.dcs.warwick.ac.uk/~acristea/courses/CS411/2010/Book%20-%20The%20Adaptive%20Web/HybridWebRecommenderSystems.pdf" target="_blank" rel="noopener">Hybrid Web Recommender Systems</a>, pp. 377-408, The Adaptive Web, Peter Brusilovsky, Alfred Kobsa, Wolfgang Nejdl (Ed.), Lecture Notes in Computer Science, Springer-Verlag, Berlin, Germany, Lecture Notes in Computer Science, Vol. 4321, May 2007, 978-3-540-72078-2.</li>
<li>P. Resnick, N. Iacovou, etc. “<a href="http://ccs.mit.edu/papers/CCSWP165.html" target="_blank" rel="noopener">GroupLens: An Open Architecture for Collaborative Filtering of Netnews</a>”, Proceedings of ACM Conference on Computer Supported Cooperative Work, CSCW 1994. pp.175-186.</li>
<li>Sarwar, Badrul, et al. “<a href="http://files.grouplens.org/papers/www10_sarwar.pdf" target="_blank" rel="noopener">Item-based collaborative filtering recommendation algorithms.</a>“ <em>Proceedings of the 10th international conference on World Wide Web</em>. ACM, 2001.</li>
<li>Kautz, Henry, Bart Selman, and Mehul Shah. “<a href="http://www.cs.cornell.edu/selman/papers/pdf/97.cacm.refweb.pdf" target="_blank" rel="noopener">Referral Web: combining social networks and collaborative filtering.</a>“ Communications of the ACM 40.3 (1997): 63-65. APA</li>
<li>Yuan, Jianbo, et al. <a href="https://arxiv.org/pdf/1611.05480v1.pdf" target="_blank" rel="noopener">“Solving Cold-Start Problem in Large-scale Recommendation Engines: A Deep Learning Approach.”</a> <em>arXiv preprint arXiv:1611.05480</em> (2016).</li>
<li>Covington P, Adams J, Sargin E. <a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/45530.pdf" target="_blank" rel="noopener">Deep neural networks for youtube recommendations</a>[C]//Proceedings of the 10th ACM Conference on Recommender Systems. ACM, 2016: 191-198.</li>
</ol>
<p><br><br><a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a><br><span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">本教程</span> 由 <a xmlns:cc="http://creativecommons.org/ns#" href="http://book.paddlepaddle.org" property="cc:attributionName" rel="noopener" target="_blank">PaddlePaddle</a> 创作，采用 <a rel="noopener" href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">知识共享 署名-相同方式共享 4.0 国际 许可协议</a>进行许可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/05/100行代码入门PaddlePaddle图像识别（无痛看代码）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yimitri">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于祥学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/05/100行代码入门PaddlePaddle图像识别（无痛看代码）/" itemprop="url">100行代码入门PaddlePaddle图像识别（无痛看代码）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-05T22:15:08+08:00">
                2018-12-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> &emsp;&emsp;<strong>导语</strong>：PaddlePaddle是由百度研发，国内首个开源的深度学习框架。你在学了N多机器学习课程后，发现要手写一个深度学习程序的时候仍会无从下手。本文目的是解决这种入门问题，适合有深度学习基础但不会写程序，或者会使用其他深度学习框架但想学习PaddlePaddle使用方式的人群。本文将带领大家将大脑中的想法及模型用PaddlePaddle框架实现出来。</p>
<p>设想一下，如果要实现一个图像分类的深度学习程序，有哪些必要的模块？首先想到的是他一定要有一个描述、定义网络结构的模块。在本文中我们就用VGG来描述网络结构，那第一个模块就是Vgg_bn_drop。有了这个网络模块我们可以推想出一定需要一个推理程序，这个程序会驱动网络模块产生一个输出，我们就叫这个输出为Predict。那第二个模块就是推理程序（Inference_Program）。我们有了Predict之后，在训练过程中自然需要将Predict与数据集中的Label进行比较，并通过损失函数来计算比较的差值。那第三个模块就是将Predict实例、Label定义、cost函数计算整合在一起的程序，它在PaddlePaddle里我们将它成为train_func，那在这里我们将第三个模块起名为train_program。在第三个模块里我们定义了cost，cost存在的意义是计算当前参数的推理与label的差值，从而调整网络中的参数，那我们就需要定义一个优化器来调整网络中的参数。所以第四个模块就是Optimizer。有了以上的四个模块，就将整个网络运转的流程（从推理到反向调整）都定义好了。<br><img src="https://upload-images.jianshu.io/upload_images/4463968-c5a5c11937f9ffbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上述结构图"></p>
<p>我们将框架定义好之后，需要一个程序将这个框架给驱动起来。这个驱动程序还有一个作用是数据灌入框架中，让数据再里面流动起来（这也是Fluid这个词的由来）。在PaddlePaddle中，可以使用Trainer这个方法来实现这个功能。之后我们只需要将数据准备好，做成reader的格式，就可以使用Trainer中的train函数来执行训练啦。<br>千里之行，至于足下。我们来看一下第一步代码该怎么写。<br>一、第一步除了导入各种库之外，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import paddle</span><br><span class="line">import paddle.fluid as fluid</span><br><span class="line">import numpy</span><br><span class="line">import sys</span><br><span class="line">from __future__ import print_function #用于提供Python3标准的print特性</span><br></pre></td></tr></table></figure></p>
<p>自然是要将我们的第一个模块——网络结构定义给实现出来。所以我们定义一个vgg_bn_drop的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def vgg_bn_drop(input):</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我们观察一下VGG的网络结构<br><img src="https://upload-images.jianshu.io/upload_images/4463968-a3197ef1a0d795b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vgg16"></p>
<p>&emsp;&emsp;可以发现VGG网络中有很多重复的部分，如果我们把这些重复的卷积操作化为一组，那么VGG中卷积的部分可以分为五组。在PaddlePaddle中对于这种连续的卷积操作可以用img_conv_group函数来实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">····<span class="function"><span class="keyword">def</span> <span class="title">conv_block</span><span class="params">(参数先空着)</span>:</span></span><br><span class="line">········<span class="keyword">return</span> fluid.nets.img_conv_group(）</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;img_conv_group是整合了卷积层、池化层、BatchNorm和DropOut的复合函数，并且可以很方便的支持连续卷及操作。我们想一下，对于每组连续卷积，我们需要定义哪些内容呢？首先它必须接受一个数据输入input。在卷积层方面，我们可以想到的是要定义卷积核大小、卷积核数量、卷积层激活函数；在池化层方面我们可以想到要定义池化区域的大小、池化窗口的步长以及池化的方法。那关于DropOut的功能我们需要提供一个DropOut的概率，在img_conv_group的参数中还有一个是否打开batchnorm的开关，需要指定一下。那么我们关img_conv_group的参数定义如下：<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">········<span class="keyword">return</span> fluid.nets.img_conv_group(</span><br><span class="line">            input=ipt,</span><br><span class="line">            conv_filter_size=<span class="number">3</span>,</span><br><span class="line">            conv_num_filter=[num_filter] * groups,</span><br><span class="line">            conv_act=<span class="string">'relu'</span>,</span><br><span class="line">            pool_size=<span class="number">2</span>,</span><br><span class="line">            pool_stride=<span class="number">2</span>,</span><br><span class="line">            pool_type=<span class="string">'max'</span></span><br><span class="line">            conv_with_batchnorm=<span class="keyword">True</span>,</span><br><span class="line">            conv_batchnorm_drop_rate=dropouts)</span><br></pre></td></tr></table></figure></p>
<p>根据VGG的网络图我们发现所有卷积层的卷积核都为3*3，那么我们在参数中就直接指定一个参数3，如果在此处给定两个参数，PaddlePaddle会认为这是个WH格式的矩形卷积核。conv_num_filte参数需要给定这组连续卷积操作中所有的卷积核数量，以用来统一初始化，所以这里需要在num_filter后乘上group的数量。根据论文我们可以知道激活函数为’relu’。根据VGG的网络图我们看到是二分之一池化，所以pool_size和pool_stride都定义为2。之后使用最大池化方法、打开batchnorm选项、指定dropout的概率。需要注意的是这里给到的dropout需要以Python中List数据结构给出，这个list存放的是连续卷积中每一层卷积的dropout概率。到这里img_conv_group的定义就完成。根据这些参数，去除硬编码的参数我们发现input、num_filter、groups、dropouts需要在上层函数中传递。所以conv_block参数如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">····<span class="function"><span class="keyword">def</span> <span class="title">conv_block</span><span class="params">(ipt, num_filter, groups, dropouts)</span>:</span></span><br></pre></td></tr></table></figure></p>
<p>所以在这一步我们的连续卷积定义就完成啦。但是我们的conv_block不能只有连续卷积的定义，还需要将他按照VGG模型的样子给组装起来。那么卷积层的组装代码为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">····conv1 = conv_block(input, <span class="number">64</span>, <span class="number">2</span>, [<span class="number">0.3</span>, <span class="number">0</span>])</span><br><span class="line">    conv2 = conv_block(conv1, <span class="number">128</span>, <span class="number">2</span>, [<span class="number">0.4</span>, <span class="number">0</span>])</span><br><span class="line">    conv3 = conv_block(conv2, <span class="number">256</span>, <span class="number">3</span>, [<span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0</span>])</span><br><span class="line">    conv4 = conv_block(conv3, <span class="number">512</span>, <span class="number">3</span>, [<span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0</span>])</span><br><span class="line">    conv5 = conv_block(conv4, <span class="number">512</span>, <span class="number">3</span>, [<span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure></p>
<p>从第二层开始，每一层接受上一层的输出，第二个参数根据VGG结构定义每一层输出的维度，第三个参数定义连续卷积的次数，第四个参数定义dropout的概率，最后一层不进行dropout操作。根据网络结构，后面需要做三层全连接操作，定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">····drop = fluid.layers.dropout(x=conv5, dropout_prob=<span class="number">0.5</span>)</span><br><span class="line">    fc1 = fluid.layers.fc(input=drop, size=<span class="number">512</span>, act=<span class="keyword">None</span>)</span><br><span class="line">    bn = fluid.layers.batch_norm(input=fc1, act=<span class="string">'relu'</span>)</span><br><span class="line">    drop2 = fluid.layers.dropout(x=bn, dropout_prob=<span class="number">0.5</span>)</span><br><span class="line">    fc2 = fluid.layers.fc(input=drop2, size=<span class="number">512</span>, act=<span class="keyword">None</span>)</span><br><span class="line">    predict = fluid.layers.fc(input=fc2, size=<span class="number">10</span>, act=<span class="string">'softmax'</span>)</span><br></pre></td></tr></table></figure></p>
<p>这里用到了PaddlePaddle内置的算子，有全连接layers.fc，batch_norm和dropout。所以整个vgg_bn_drop代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vgg_bn_drop</span><span class="params">(input)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">conv_block</span><span class="params">(ipt, num_filter, groups, dropouts)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> fluid.nets.img_conv_group(</span><br><span class="line">            input=ipt,</span><br><span class="line">            pool_size=<span class="number">2</span>,</span><br><span class="line">            pool_stride=<span class="number">2</span>,</span><br><span class="line">            conv_num_filter=[num_filter] * groups,</span><br><span class="line">            conv_filter_size=<span class="number">3</span>,</span><br><span class="line">            conv_act=<span class="string">'relu'</span>,</span><br><span class="line">            conv_with_batchnorm=<span class="keyword">True</span>,</span><br><span class="line">            conv_batchnorm_drop_rate=dropouts,</span><br><span class="line">            pool_type=<span class="string">'max'</span>)</span><br><span class="line"></span><br><span class="line">    conv1 = conv_block(input, <span class="number">64</span>, <span class="number">2</span>, [<span class="number">0.3</span>, <span class="number">0</span>])</span><br><span class="line">    conv2 = conv_block(conv1, <span class="number">128</span>, <span class="number">2</span>, [<span class="number">0.4</span>, <span class="number">0</span>])</span><br><span class="line">    conv3 = conv_block(conv2, <span class="number">256</span>, <span class="number">3</span>, [<span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0</span>])</span><br><span class="line">    conv4 = conv_block(conv3, <span class="number">512</span>, <span class="number">3</span>, [<span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0</span>])</span><br><span class="line">    conv5 = conv_block(conv4, <span class="number">512</span>, <span class="number">3</span>, [<span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    drop = fluid.layers.dropout(x=conv5, dropout_prob=<span class="number">0.5</span>)</span><br><span class="line">    fc1 = fluid.layers.fc(input=drop, size=<span class="number">512</span>, act=<span class="keyword">None</span>)</span><br><span class="line">    bn = fluid.layers.batch_norm(input=fc1, act=<span class="string">'relu'</span>)</span><br><span class="line">    drop2 = fluid.layers.dropout(x=bn, dropout_prob=<span class="number">0.5</span>)</span><br><span class="line">    fc2 = fluid.layers.fc(input=drop2, size=<span class="number">512</span>, act=<span class="keyword">None</span>)</span><br><span class="line">    predict = fluid.layers.fc(input=fc2, size=<span class="number">10</span>, act=<span class="string">'softmax'</span>)</span><br><span class="line">    <span class="keyword">return</span> predict</span><br></pre></td></tr></table></figure></p>
<p>二、定义好网络结构以后，我们需要将网络的输出Predict给接住，并且将它的奶嘴（输入格式）给备好，所以我们定义<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inference_program</span><span class="params">()</span>:</span></span><br></pre></td></tr></table></figure></p>
<p>方法时要先接住输出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">predict = vgg_bn_drop(images)</span><br></pre></td></tr></table></figure></p>
<p>再喂上奶嘴：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data_shape = [<span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>]</span><br><span class="line">images = fluid.layers.data(name=<span class="string">'pixel'</span>, shape=data_shape, dtype=<span class="string">'float32'</span>)</span><br><span class="line">predict = vgg_bn_drop(images) <span class="comment"># un-comment to use vgg net</span></span><br></pre></td></tr></table></figure></p>
<p>在PaddlePaddle中，无论是图像数据，张量数据还是标签数据，都可以用layers.data容器来存放。在data函数中，’name’参数是可以自定义指定的。因为本实验是使用cifar10的数据，是3通道32x32的图片。所以inference_program的代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inference_program</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># The image is 32 * 32 with RGB representation.</span></span><br><span class="line">    data_shape = [<span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>]</span><br><span class="line">    images = fluid.layers.data(name=<span class="string">'pixel'</span>, shape=data_shape, dtype=<span class="string">'float32'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#predict = resnet_cifar10(images, 32)</span></span><br><span class="line">    predict = vgg_bn_drop(images) <span class="comment"># un-comment to use vgg net</span></span><br><span class="line">    <span class="keyword">return</span> predict</span><br></pre></td></tr></table></figure></p>
<p>三、根据开头讲的思路，我们有了推理模块后，需要将Predict和label进行交叉对比计算，所以我们需要一个train_program。train_program起到的作用是定义label、计算损失函数、计算准确率。他需要将每一批的平均cost和准确率转给下一步的优化器。所以train_program的定义如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_program</span><span class="params">()</span>:</span></span><br><span class="line">    predict = inference_program()</span><br><span class="line">    label = fluid.layers.data(name=<span class="string">'label'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">'int64'</span>)</span><br><span class="line">    cost = fluid.layers.cross_entropy(input=predict, label=label)</span><br><span class="line">    avg_cost = fluid.layers.mean(cost)</span><br><span class="line">    accuracy = fluid.layers.accuracy(input=predict, label=label)</span><br><span class="line">    <span class="keyword">return</span> [avg_cost, accuracy]</span><br></pre></td></tr></table></figure></p>
<p>我们得到cost之后，在训练过程需要根据cost返回的数据来反向调整神经网络中的参数，那反向调整参数的模块就叫optimizer_program，我们对optimizer_program的定义只需要返回指定的optimizer即可（在这里指定学习率超参数）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimizer_program</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> fluid.optimizer.Adam(learning_rate=<span class="number">0.001</span>)</span><br></pre></td></tr></table></figure></p>
<p>四、有了以上三个模块，训练-推理-调整这一个有向循环图就构成了。现在我们就像已经将自来水管道修好，需要往里通水的状态。那我们整个循环系统的中控程序是什么呢？是fluid.Trainer。在PaddlePaddle中fluid.Trainer是一个较高层的API，使用时只需将fluid.Trainer这个类实例化即可，启动实例化对象中的.train()方法即可启动网络训练。那这就涉及到了两个步骤：实例化对象和启动训练。</p>
<p>五、在实例化对象时需要指定3个参数：train_func、optimizer和place。train_func就是我们刚才定义的train_program，它包含了网络正向推理及cost的所有信息，只需将train_program传递给train_func参数就好。optimizer如同一辙。place的含义是整个训练程序在哪个设备上运行，不用多说，计算机中进行大规模计算的硬件只有CPU和GPU。为了程序设计规范，我们设置一个指定设备的开关：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use_cuda = <span class="keyword">False</span></span><br><span class="line">place = fluid.CUDAPlace(<span class="number">0</span>) <span class="keyword">if</span> use_cuda <span class="keyword">else</span> fluid.CPUPlace()</span><br></pre></td></tr></table></figure></p>
<p>这样我们就可以将Trainer实例化部分给写出来了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use_cuda = <span class="keyword">False</span></span><br><span class="line">place = fluid.CUDAPlace(<span class="number">0</span>) <span class="keyword">if</span> use_cuda <span class="keyword">else</span> fluid.CPUPlace()</span><br><span class="line">trainer = fluid.Trainer(</span><br><span class="line">    train_func=train_program,</span><br><span class="line">    optimizer_func=optimizer_program,</span><br><span class="line">    place=place)</span><br></pre></td></tr></table></figure></p>
<p>六、读到这里是不是想赶紧运行一下trainer.train()赶紧让他先跑起来？且慢，我们发现，我们只定义了数据的容器（杯子），且从没有处理让真正数据读进网络的代码（水）。所以我们还需要写一个数据读取、预处理的模块。因为图像识别的网络都是将图片一批一批训练的，所以显而易见我们需要数据读入和分批这两个操作。PaddlePaddle在daraset包里存放个各种各样公开数据库的API，一句话就可以调用这些数据包，并返回Python reader格式的数据。所以我们的流程是先将数据从API中读出来，然后做乱序处理，之后用batch函数进行分批操作（在这里指定BATCH_SIZE超参数）：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Each batch will yield 128 images</span></span><br><span class="line">BATCH_SIZE = <span class="number">128</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reader for training</span></span><br><span class="line">train_reader = paddle.batch(</span><br><span class="line">    paddle.reader.shuffle(paddle.dataset.cifar.train10(), buf_size=<span class="number">50000</span>),</span><br><span class="line">    batch_size=BATCH_SIZE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reader for testing. A separated data set for testing.</span></span><br><span class="line">test_reader = paddle.batch(</span><br><span class="line">    paddle.dataset.cifar.test10(), batch_size=BATCH_SIZE)</span><br></pre></td></tr></table></figure></p>
<p>七、是不是觉得有了数据就可以跑起来了？Naive~ 在trainer中，必须指定一个事件处理函数才可以运行。这个函数的作用是观察、调试参数，保存参数模型。这里我们用画图的方式来观察网络中cost参数的变化过程：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">params_dirname = <span class="string">"image_classification_resnet.inference.model"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> paddle.v2.plot <span class="keyword">import</span> Ploter</span><br><span class="line"></span><br><span class="line">train_title = <span class="string">"Train cost"</span></span><br><span class="line">test_title = <span class="string">"Test cost"</span></span><br><span class="line">cost_ploter = Ploter(train_title, test_title)</span><br><span class="line"></span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">event_handler_plot</span><span class="params">(event)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> step</span><br><span class="line">    <span class="keyword">if</span> isinstance(event, fluid.EndStepEvent):</span><br><span class="line">        cost_ploter.append(train_title, step, event.metrics[<span class="number">0</span>])</span><br><span class="line">        cost_ploter.plot()</span><br><span class="line">        step += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(event, fluid.EndEpochEvent):</span><br><span class="line">        avg_cost, accuracy = trainer.test(</span><br><span class="line">            reader=test_reader,</span><br><span class="line">            feed_order=[<span class="string">'pixel'</span>, <span class="string">'label'</span>])</span><br><span class="line">        cost_ploter.append(test_title, step, avg_cost)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># save parameters</span></span><br><span class="line">        <span class="keyword">if</span> params_dirname <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            trainer.save_params(params_dirname)</span><br></pre></td></tr></table></figure></p>
<p>使用paddle.v2.plot可以轻松在ipython notebook中将参数点在图像中画出来，核心代码只有一个 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">八、现在可以执行训练了，启动trainer.train方法需要指定4个必要参数：reader（Python reader格式的数据流）、num_epochs（对数据集训练轮次的超参数）、event_handler（事件处理函数）、feed_order（存放训练数据和标签的容器）。所以代码如下：</span><br><span class="line">```Python</span><br><span class="line">trainer.train(</span><br><span class="line">    reader=train_reader,</span><br><span class="line">    num_epochs=2,</span><br><span class="line">    event_handler=event_handler_plot,</span><br><span class="line">    feed_order=[&apos;pixel&apos;, &apos;label&apos;])</span><br></pre></td></tr></table></figure></p>
<p>等待一会就可以看到输出不断变化的cost值了：<br><img src="https://upload-images.jianshu.io/upload_images/4463968-2fd759c7a2db3646.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="横坐标为训练批次数，纵坐标为cost的批次均值"></p>
<p>九、在训练一轮数据集之后，模型便保存在我们制定的路径中了。那如何使用这个模型来进行预测呢？PaddlePaddle的预测代码很简单，先实例化一个预测引擎<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```Python</span><br><span class="line">inferencer = fluid.Inferencer(infer_func=inference_program, param_path=params_dirname, place=place)</span><br><span class="line">results = inferencer.infer(&#123;&apos;pixel&apos;: img&#125;)</span><br></pre></td></tr></table></figure></p>
<p>我们从results中取到的是由每一分类的似然值构成的List。ifar.train10是10分类数据，所以我们将这个分类的名称用人类的语言来描述一下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label_list = [<span class="string">"airplane"</span>, <span class="string">"automobile"</span>, <span class="string">"bird"</span>, <span class="string">"cat"</span>, <span class="string">"deer"</span>, <span class="string">"dog"</span>, <span class="string">"frog"</span>, <span class="string">"horse"</span>, <span class="string">"ship"</span>, <span class="string">"truck"</span>]</span><br></pre></td></tr></table></figure></p>
<p>然后result这个List中用np.argmax取最大概率的位置值，将其对应的label输出就得到了我们想要的分类了：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"infer results: %s"</span> % label_list[np.argmax(results[<span class="number">0</span>])])</span><br></pre></td></tr></table></figure></p>
<p>你以为大功告成了吗？仔细看一下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">```Python</span><br><span class="line"># Prepare testing data.</span><br><span class="line">from PIL import Image</span><br><span class="line">import numpy as np</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">def load_image(file):</span><br><span class="line">    im = Image.open(file)</span><br><span class="line">    im = im.resize((32, 32), Image.ANTIALIAS)</span><br><span class="line"></span><br><span class="line">    im = np.array(im).astype(np.float32)#浮点精度转换</span><br><span class="line">    im = im.transpose((2, 0, 1))  # 转为CHW顺序</span><br><span class="line">    im = im / 255.0 #归一化在[-1,1]的区间内</span><br><span class="line"></span><br><span class="line">    # Add one dimension to mimic the list format.</span><br><span class="line">    im = numpy.expand_dims(im, axis=0)</span><br><span class="line">    return im</span><br><span class="line"></span><br><span class="line">cur_dir = os.getcwd()#拼接为绝对地址</span><br><span class="line">img = load_image( &apos;./image/dog.png&apos;)#要预测图像的地址</span><br></pre></td></tr></table></figure></p>
<p>所以我们的整段预测代码为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Prepare testing data.</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_image</span><span class="params">(file)</span>:</span></span><br><span class="line">    im = Image.open(file)</span><br><span class="line">    im = im.resize((<span class="number">32</span>, <span class="number">32</span>), Image.ANTIALIAS)</span><br><span class="line"></span><br><span class="line">    im = np.array(im).astype(np.float32)</span><br><span class="line">    <span class="comment"># The storage order of the loaded image is W(width),</span></span><br><span class="line">    <span class="comment"># H(height), C(channel). PaddlePaddle requires</span></span><br><span class="line">    <span class="comment"># the CHW order, so transpose them.</span></span><br><span class="line">    im = im.transpose((<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>))  <span class="comment"># CHW</span></span><br><span class="line">    im = im / <span class="number">255.0</span> <span class="comment">#-1 - 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add one dimension to mimic the list format.</span></span><br><span class="line">    im = numpy.expand_dims(im, axis=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> im</span><br><span class="line"></span><br><span class="line">cur_dir = os.getcwd()</span><br><span class="line">img = load_image(cur_dir + <span class="string">'/03.image_classification/image/dog.png'</span>)</span><br><span class="line"><span class="comment">#img = load_image( './image/dog.png')</span></span><br><span class="line"></span><br><span class="line">inferencer = fluid.Inferencer(infer_func=inference_program, param_path=params_dirname, place=place)</span><br><span class="line"></span><br><span class="line">label_list = [<span class="string">"airplane"</span>, <span class="string">"automobile"</span>, <span class="string">"bird"</span>, <span class="string">"cat"</span>, <span class="string">"deer"</span>, <span class="string">"dog"</span>, <span class="string">"frog"</span>, <span class="string">"horse"</span>, <span class="string">"ship"</span>, <span class="string">"truck"</span>]</span><br><span class="line"><span class="comment"># inference</span></span><br><span class="line">results = inferencer.infer(&#123;<span class="string">'pixel'</span>: img&#125;)</span><br><span class="line"><span class="comment">#print(results[0])</span></span><br><span class="line">print(<span class="string">"infer results: %s"</span> % label_list[np.argmax(results[<span class="number">0</span>])+<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p>
<p>十、附整个过程的完整代码：<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line"><span class="keyword">import</span> paddle.fluid <span class="keyword">as</span> fluid</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vgg_bn_drop</span><span class="params">(input)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">conv_block</span><span class="params">(ipt, num_filter, groups, dropouts)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> fluid.nets.img_conv_group(</span><br><span class="line">            input=ipt,</span><br><span class="line">            pool_size=<span class="number">2</span>,</span><br><span class="line">            pool_stride=<span class="number">2</span>,</span><br><span class="line">            conv_num_filter=[num_filter] * groups,</span><br><span class="line">            conv_filter_size=<span class="number">3</span>,</span><br><span class="line">            conv_act=<span class="string">'relu'</span>,</span><br><span class="line">            conv_with_batchnorm=<span class="keyword">True</span>,</span><br><span class="line">            conv_batchnorm_drop_rate=dropouts,</span><br><span class="line">            pool_type=<span class="string">'max'</span>)</span><br><span class="line"></span><br><span class="line">    conv1 = conv_block(input, <span class="number">64</span>, <span class="number">2</span>, [<span class="number">0.3</span>, <span class="number">0</span>])</span><br><span class="line">    conv2 = conv_block(conv1, <span class="number">128</span>, <span class="number">2</span>, [<span class="number">0.4</span>, <span class="number">0</span>])</span><br><span class="line">    conv3 = conv_block(conv2, <span class="number">256</span>, <span class="number">3</span>, [<span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0</span>])</span><br><span class="line">    conv4 = conv_block(conv3, <span class="number">512</span>, <span class="number">3</span>, [<span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0</span>])</span><br><span class="line">    conv5 = conv_block(conv4, <span class="number">512</span>, <span class="number">3</span>, [<span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    drop = fluid.layers.dropout(x=conv5, dropout_prob=<span class="number">0.5</span>)</span><br><span class="line">    fc1 = fluid.layers.fc(input=drop, size=<span class="number">512</span>, act=<span class="keyword">None</span>)</span><br><span class="line">    bn = fluid.layers.batch_norm(input=fc1, act=<span class="string">'relu'</span>)</span><br><span class="line">    drop2 = fluid.layers.dropout(x=bn, dropout_prob=<span class="number">0.5</span>)</span><br><span class="line">    fc2 = fluid.layers.fc(input=drop2, size=<span class="number">512</span>, act=<span class="keyword">None</span>)</span><br><span class="line">    predict = fluid.layers.fc(input=fc2, size=<span class="number">10</span>, act=<span class="string">'softmax'</span>)</span><br><span class="line">    <span class="keyword">return</span> predict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inference_program</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># The image is 32 * 32 with RGB representation.</span></span><br><span class="line">    data_shape = [<span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>]</span><br><span class="line">    images = fluid.layers.data(name=<span class="string">'pixel'</span>, shape=data_shape, dtype=<span class="string">'float32'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#predict = resnet_cifar10(images, 32)</span></span><br><span class="line">    predict = vgg_bn_drop(images) <span class="comment"># un-comment to use vgg net</span></span><br><span class="line">    <span class="keyword">return</span> predict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_program</span><span class="params">()</span>:</span></span><br><span class="line">    predict = inference_program()</span><br><span class="line"></span><br><span class="line">    label = fluid.layers.data(name=<span class="string">'label'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">'int64'</span>)</span><br><span class="line">    cost = fluid.layers.cross_entropy(input=predict, label=label)</span><br><span class="line">    avg_cost = fluid.layers.mean(cost)</span><br><span class="line">    accuracy = fluid.layers.accuracy(input=predict, label=label)</span><br><span class="line">    <span class="keyword">return</span> [avg_cost, accuracy]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimizer_program</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> fluid.optimizer.Adam(learning_rate=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">use_cuda = <span class="keyword">False</span></span><br><span class="line">place = fluid.CUDAPlace(<span class="number">0</span>) <span class="keyword">if</span> use_cuda <span class="keyword">else</span> fluid.CPUPlace()</span><br><span class="line">trainer = fluid.Trainer(</span><br><span class="line">    train_func=train_program,</span><br><span class="line">    optimizer_func=optimizer_program,</span><br><span class="line">    place=place)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Each batch will yield 128 images</span></span><br><span class="line">BATCH_SIZE = <span class="number">128</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Reader for training</span></span><br><span class="line">train_reader = paddle.batch(</span><br><span class="line">    paddle.reader.shuffle(paddle.dataset.cifar.train10(), buf_size=<span class="number">50000</span>),</span><br><span class="line">    batch_size=BATCH_SIZE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Reader for testing. A separated data set for testing.</span></span><br><span class="line">test_reader = paddle.batch(</span><br><span class="line">    paddle.dataset.cifar.test10(), batch_size=BATCH_SIZE)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">params_dirname = <span class="string">"image_classification_resnet.inference.model"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> paddle.v2.plot <span class="keyword">import</span> Ploter</span><br><span class="line"></span><br><span class="line">train_title = <span class="string">"Train cost"</span></span><br><span class="line">test_title = <span class="string">"Test cost"</span></span><br><span class="line">cost_ploter = Ploter(train_title, test_title)</span><br><span class="line"></span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">event_handler_plot</span><span class="params">(event)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> step</span><br><span class="line">    <span class="keyword">if</span> isinstance(event, fluid.EndStepEvent):</span><br><span class="line">        cost_ploter.append(train_title, step, event.metrics[<span class="number">0</span>])</span><br><span class="line">        cost_ploter.plot()</span><br><span class="line">        step += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(event, fluid.EndEpochEvent):</span><br><span class="line">        avg_cost, accuracy = trainer.test(</span><br><span class="line">            reader=test_reader,</span><br><span class="line">            feed_order=[<span class="string">'pixel'</span>, <span class="string">'label'</span>])</span><br><span class="line">        cost_ploter.append(test_title, step, avg_cost)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># save parameters</span></span><br><span class="line">        <span class="keyword">if</span> params_dirname <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            trainer.save_params(params_dirname)</span><br><span class="line"></span><br><span class="line">trainer.train(</span><br><span class="line">    reader=train_reader,</span><br><span class="line">    num_epochs=<span class="number">2</span>,</span><br><span class="line">    event_handler=event_handler_plot,</span><br><span class="line">    feed_order=[<span class="string">'pixel'</span>, <span class="string">'label'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prepare testing data.</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_image</span><span class="params">(file)</span>:</span></span><br><span class="line">    im = Image.open(file)</span><br><span class="line">    im = im.resize((<span class="number">32</span>, <span class="number">32</span>), Image.ANTIALIAS)</span><br><span class="line"></span><br><span class="line">    im = np.array(im).astype(np.float32)</span><br><span class="line">    <span class="comment"># The storage order of the loaded image is W(width),</span></span><br><span class="line">    <span class="comment"># H(height), C(channel). PaddlePaddle requires</span></span><br><span class="line">    <span class="comment"># the CHW order, so transpose them.</span></span><br><span class="line">    im = im.transpose((<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>))  <span class="comment"># CHW</span></span><br><span class="line">    im = im / <span class="number">255.0</span> <span class="comment">#-1 - 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add one dimension to mimic the list format.</span></span><br><span class="line">    im = numpy.expand_dims(im, axis=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> im</span><br><span class="line"></span><br><span class="line">cur_dir = os.getcwd()</span><br><span class="line">img = load_image(cur_dir + <span class="string">'/03.image_classification/image/dog.png'</span>)</span><br><span class="line"><span class="comment">#img = load_image( './image/dog.png')</span></span><br><span class="line"></span><br><span class="line">inferencer = fluid.Inferencer(infer_func=inference_program, param_path=params_dirname, place=place)</span><br><span class="line"></span><br><span class="line">label_list = [<span class="string">"airplane"</span>, <span class="string">"automobile"</span>, <span class="string">"bird"</span>, <span class="string">"cat"</span>, <span class="string">"deer"</span>, <span class="string">"dog"</span>, <span class="string">"frog"</span>, <span class="string">"horse"</span>, <span class="string">"ship"</span>, <span class="string">"truck"</span>]</span><br><span class="line"><span class="comment"># inference</span></span><br><span class="line">results = inferencer.infer(&#123;<span class="string">'pixel'</span>: img&#125;)</span><br><span class="line"><span class="comment">#print(results[0])</span></span><br><span class="line">print(<span class="string">"infer results: %s"</span> % label_list[np.argmax(results[<span class="number">0</span>])+<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/05/牛顿迭代法-Newton-s-Method/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yimitri">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于祥学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/05/牛顿迭代法-Newton-s-Method/" itemprop="url">牛顿迭代法(Newton's Method)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-05T20:39:27+08:00">
                2018-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数学漫步/" itemprop="url" rel="index">
                    <span itemprop="name">数学漫步</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>简介</strong><br><blockquote><p>牛顿迭代法（简称牛顿法）由英国著名的数学家牛顿爵士最早提出。但是，这一方法在牛顿生前并未公开发表。</p>
</blockquote></p>
<p><img src="http://openarena.ws/shots/076/slimefac.jpg" alt="使用牛顿迭代法了的雷神之锤3引擎——OpenArena"></p>
<p>牛顿法的作用是使用迭代的方法来求解函数方程的根。简单地说，牛顿法就是不断求取切线的过程。</p>
<p>对于形如f(x)=0的方程，首先任意估算一个解x0，再把该估计值代入原方程中。由于一般不会正好选择到正确的解，所以有f(x)=a。这时计算函数在x0处的斜率，和这条斜率与x轴的交点x1。</p>
<p>f(x)=0中精确解的意义是，当取得解的时候，函数值为零（即f(x)的精确解是函数的零点）。因此，x1比x0更加接近精确的解。只要不断以此方法更新x，就可以取得无限接近的精确的解。</p>
<p>但是，有可能会遇到牛顿迭代法无法收敛的情况。比如函数有多个零点，或者函数不连续的时候。</p>
<p><strong>牛顿法举例</strong><br><img src="/2018/12/05/牛顿迭代法-Newton-s-Method/Users/v_yuxiang/Desktop/Blog_hexo/source/_posts/20140113020213546.jpg" alt=""></p>
<p>下面介绍使用牛顿迭代法求方根的例子。牛顿迭代法是已知的实现求方根最快的方法之一,只需要迭代几次后就能得到相当精确的结果。</p>
<p>首先设x的m次方根为a。</p>
<p>下面程序使用牛顿法求解平方根。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> EPS = <span class="number">0.00001</span>;   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">double</span> result = x; <span class="comment">/*Use double to avoid possible overflow*/</span>   </span><br><span class="line">    <span class="keyword">double</span> lastValue;   </span><br><span class="line">    <span class="keyword">do</span>&#123;   </span><br><span class="line">        lastValue = result;   </span><br><span class="line">        result = result / <span class="number">2.0f</span> + x / <span class="number">2.0f</span> / result;   </span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="built_in">abs</span>(result - lastValue) &gt; EPS);  </span><br><span class="line"> <span class="keyword">return</span> (<span class="keyword">double</span>)result;  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure></p>
<p><strong>更快的方法是</strong></p>
<p>文献2提到了比上述程序更快的求解平方根的非典型牛顿迭代法。介绍如下。</p>
<p>1999年12月，美国id Software公司发布了名为“雷神之锤III”的电子游戏。它是第一个支持软件加速的游戏，取得了极大成功。（由于影响力过大，文化部于2004年将它列入了非法游戏名单）</p>
<p>雷神之锤III并不是id Software公司的第一次成功。早在1993年开始，这家公司就以“毁灭战士”系列游戏名闻天下。1995年，“毁灭战士”的安装数超过了当年微软的windows 95。据传比尔盖茨才曾经考虑买下id software。（id software公司后来被推出过“上古卷轴”系列的Bethesda公司买下）</p>
<p>id Software所取得的成功很大程度上要归功于它的创始人约翰·卡马克。马克尔也是一个著名的程序员，他是id Software游戏引擎的主要负责人。 回到刚才提到的雷神之锤，马克尔是开源软件的积极推动者，他于2005年公布了雷神之锤III的源代码。至此人们得以通过研究这款游戏引擎的源文件来查看它成功的秘密。</p>
<p>在其中一个名字为q_math.c的文件中发现了如下代码段。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Q_rsqrt</span><span class="params">( <span class="keyword">float</span> number )</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">long</span> i; <span class="keyword">float</span> x2, y; <span class="keyword">const</span> <span class="keyword">float</span> threehalfs = <span class="number">1.5F</span>;  </span><br><span class="line">    x2 = number * <span class="number">0.5F</span>;   </span><br><span class="line">    y = number;   </span><br><span class="line">    i = * ( <span class="keyword">long</span> * ) &amp;y; <span class="comment">// evil floating point bit level hacking   </span></span><br><span class="line">    i = <span class="number">0x5f3759df</span> - ( i &gt;&gt; <span class="number">1</span> ); <span class="comment">// what the fuck?   </span></span><br><span class="line">    y = * ( <span class="keyword">float</span> * ) &amp;i;   </span><br><span class="line">    y = y * ( threehalfs - ( x2 * y * y ) ); <span class="comment">// 1st iteration   </span></span><br><span class="line">    <span class="comment">// y = y * ( threehalfs - ( x2 * y * y ) ); // 2nd iteration, this can be removed  </span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> Q3_VM #  </span></span><br><span class="line">    ifdef __<span class="function">linux__ <span class="title">assert</span><span class="params">( !isnan(y) )</span></span>; <span class="comment">// bk010122 - FPE?  </span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span> return y;   </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><br>这段代码的作用就是求number的平方根，并且返回它的倒数。</p>
<p>经过测试，它的效率比上述牛顿法程序要快几十倍。也比c++标准库的sqrt()函数要快好几倍。此段代码有一个奇怪的句子：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0x5f3759df</span> - ( i &gt;&gt; <span class="number">1</span> ); <span class="comment">// what the fuck? </span></span><br></pre></td></tr></table></figure><br>这句话的注释是“what the fuck?”，翻译过来就是“我靠？”</p>
<p>任何受过程序训练的人看到这句大概都会在想，这句话到底在搞什么鸟？</p>
<p>之所以会出现这种奇怪的注释，要么是此段程序的作者（可能是马克尔）根本不知道该如何解释清楚，或者是维护这段程序的程序员完全看不懂这句话，所以有点儿抓毛。而实际上，它的作用（再加上y = y <em> ( threehalfs - ( x2 </em> y * y ) )这句牛顿迭代）就是求平方根。</p>
<p>至于是为什么，我也不知道。</p>
<p>以雷神之锤III程序为蓝本可以写出比sqrt()更强大的求平方根函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">float</span> result = x;   </span><br><span class="line">    <span class="keyword">float</span> xhalf = <span class="number">0.5f</span>*result;   </span><br><span class="line">    <span class="keyword">int</span> i = *(<span class="keyword">int</span>*)&amp;result;   </span><br><span class="line">    i = <span class="number">0x5f375a86</span>- (i&gt;&gt;<span class="number">1</span>); <span class="comment">// what the fuck?   </span></span><br><span class="line">    result = *(<span class="keyword">float</span>*)&amp;i;   </span><br><span class="line">    result = result*(<span class="number">1.5f</span>-xhalf*result*result); <span class="comment">// Newton step, repeating increases accuracy   </span></span><br><span class="line">    result = result*(<span class="number">1.5f</span>-xhalf*result*result);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0f</span>/result;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/03/hello-world/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yimitri">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="于祥学习笔记">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/03/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-03T21:10:22+08:00">
                2018-12-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yimitri</p>
              <p class="site-description motion-element" itemprop="description">深度学习 机器学习 网络安全 神经网络</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yimitri</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
